我们首先定义变量：
对每个关键字ki，都有一个概率pi表示其搜索频率。
对每个伪关键字di，也都有一个概率qi表示对应的搜索频率

步骤
1：最优二叉搜索树的结构
   为了刻画最优二叉搜索树的结构，我们从观察子树特征开始。考虑一棵二叉搜索树的任意子树。
   它必须包含连续关键字k(i),...k(j)，1<=i<=j<=n，而且其叶结点必然是
   伪关键字d(i-1),...,d(i)。
   我们现在可以给出二叉搜索树问题的最优子结构：如果一棵最优二叉搜索树T有一棵包含关键字k(i),...,k(j)
   的子树T'，那么T'必然是包含关键字k(i),...,k(j)和伪关键字d(i-1),...,d(j)的子问题的最优解。
步骤2：一个递归算法
   我们已经准备好给出最优解值的递归定义。我们选取子问题域为：
   求解包含关键字k(i),...,k(j)的最优二叉搜索树，其中i>=1，j<=n且j>=i-1(当j=i-1时，
   子树不包含实际关键字，只包含伪关键字d(i-1)。定义e[i,j]为包含关键字k(i),...,k(j)
 的最优二叉搜索树中进行一次搜索的期望代价，最终，我们希望计算出e[1,n]。

   1.j=i-1的情况最为简单，由于子树只包含伪关键字d(i-1)，期望搜索代价为e[i,i-1]=q(i-1)。
   2.当j>=i时，我们需要从k(i),...,k(j)中选择一个跟结点k(r)，然后构造一棵包含关键字
    k(i),...,k(r-1)的最优二叉搜索树作为其左子树，以及一棵包含关键字k(r+1),...,k(j)
        的二叉搜索树作为其右子树。当一棵子树成为一个结点的子树时，期望搜索代价有何变化？
        由于每个结点的深度都增加了1，这棵子树的期望搜索代价的增加值应为所有概率
        这和。对于包含关键字k(i),...,k(j)的子树，所有概率之和为
         w(i, j) = sum(pl)(l from i to j) + sum(ql)(l from i-1 to j)[公式１]
         注意：这里的l是下标
 	  因此，若k为包含关键字k(i),...,k(j)的最优二叉搜索树的根结点，我们有如下公式：
         e[i,j]=p(r)+(e[i,r-1]+w(i,r-1))+(e[r+1,j]+w(r+1,j)) 注意，w(i,j)=w(i,r-1)+p(r)+w(r+1,j)。
        因此e[i,j]可重写为：
         e[i,j]=e[i,r-1]+e[r+1,j]+w(i,j)  [公式2]
         假定我们知道哪个结点k应该作为根结点。如果选取期望搜索代价最低者作为根结点，可得最终递归公式(15.14)：
        a,若j=i-1，e[i,j]=q(i-1)。
        b,若i<=j，e[i,j]=min{e[i,r-1]+e[r+1,j]+w(i,j)}(i<=r<=j)[公式3]
     e[i,j]的值给出了最优二叉搜索树的期望搜索代价。为了记录最优二叉搜索树的结构，对于包含关键字
     k(i),...,k(j)(1<=i<=j<=n)的最优二叉搜索树，我们定义root[i,j]保存根结点k(r)的下标r。
      这个问题的子问题都由连续的下标子域组成。而公式(2)的直接递归实现，也会与矩阵链乘法问题的直接
      递归算法一样低效。因此，我们设计替代的高效算法，我们用一个表e[1..n+1,0..n]来保存e[i,j]
      的值。第一维下标上界为n+1而不是n，原因在于对于只包含伪关键字d(n)的子树，
      我们需要计算并保存e[n+1,n]。第二维下标下界为0，是因为对于只包含伪关键字d0的子树，
      我们需要计算并保存e[1,0]。我们只使用表中满足j>=i-1的表项e[i,j]。我们还使用一个表root
      记录关键字ki,...kj的子树的根。我们只使用此表中满足1<=i<=j<=n的表项root[i,j];
     我们还需要另一个表来提高计算效率。为了避免每次计算e[i,j]时都重新计算w(i,j)，
     我们将这些值保存在表w[1..n+1,0..n]中，这样每次可节省Θ(j-i)次加法。对基本情况，
     令w[i,i-1]=q(i-1)(1<=i<=n+1)。对j>=i的情况，可如下计算：
           w[i,j]=w[i,j-1]+p(j)+q(j)
